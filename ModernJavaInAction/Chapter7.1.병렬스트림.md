# 병렬 스트림

자바 7이 등장하기 전에는 데이터 컬렉션을 병렬로 처리하기 어려웠음

1. **스레드 관리의 어려움:** 
- 자바 7 이전에는 병렬 프로그래밍을 위해 명시적으로 스레드를 생성하고 관리해야 했음
- 스레드 관리는 복잡하고 오류가 발생하기 쉬웠습니다. 올바른 동기화 및 스레드 안전성을 보장하기 위해 많은 수동 조치가 필요함

2. **동기화의 복잡성:** 
- 여러 스레드가 공유 데이터를 동시에 수정할 때 발생하는 동기화 문제가 복잡함
- 적절한 락(Lock)을 사용하거나 원자적 연산을 보장하는 방법 등을 고려해야 했음

3. **디버깅과 테스트의 어려움:** 
- 병렬 프로그래밍은 디버깅과 테스트를 어렵게 만들 수 있었음
- 레이스 컨디션(Race Condition)과 데드락(Deadlock) 같은 문제들이 발생할 수 있었고, 이를 찾고 해결하는 것이 어려움

4. **성능 향상을 위한 하드웨어 지원 부족:** 
- 당시 대다수의 컴퓨터가 싱글 코어(CPU)를 사용하고 있었기 때문에, 병렬 프로그래밍이 성능 향상을 얻기 어려웠음
- 하드웨어에서 병렬 실행을 효과적으로 지원하기 위해서는 멀티코어 프로세서와 관련된 기술과 하드웨어 지원이 필요했음

자바 7에서는 Fork/Join 프레임워크가 도입되면서, 데이터 컬렉션을 더 쉽게 병렬로 처리할 수 있는 기능이 추가되었다

Fork/Join 프레임워크는 작업을 작은 작업 단위로 분할하고, 분할된 작업들을 병렬로 처리한 다음 결과를 합치는 방식으로 동작하여 병렬 처리를 효율적으로 수행할 수 있도록 지원한다

스트림을 이용하면 순차 스트림을 병렬 스트림으로 쉽게 바꿀 수 있음

### parallelStram 병렬 스트림 생성
스트림 인터페이스를 사용하여 데이터 요소를 병렬로 처리할 수 있음

병렬스트림: 각각의 스레드에서 병렬로 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림

```java
  public long sequentialSum(long n) {
        return Stream.iterate(1L, i -> i+1)
                .limit(n)
                .reduce(0L, Long::sum); // 모든 숫자를 더하는 스트림 리듀싱 연산
    } // n이 커질 수록 병렬로 처리하는 것이 좋음.
```

for문으로 모든 합을 더하던 나에서 reduce()로 합산을 구하는 내가 된... 

만약 n이 백만스물한개가 된다면 성능은 좋지 않아질 것이다. 

데이터 요소가 많아진다면 병렬로 처리하는 것이 좋다.

### 순차 스트림을 병렬 스트림으로 변환하기

순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 recude 연산이 병렬로 처리됨

```java
public long parallelSum(long n) {
        return Stream.iterate(1L, i -> i + 1)
                .limit(n)
                .parallel()
                .reduce(0L, Long::sum);
    }
```

parallel 함수만 썼을 뿐인데, 스트림이 여러 청크로 분할 되어 연산이 진행된다

리듀싱 연산을 여러 청크에 병렬로 수행할 수 있고, 리듀싱 연산된 결과를 다시 리듀싱 연산으로 합쳐서 전체 스트림 리듀싱 결과를 도출할 수 있다

순차 스트림에 parallel를 호출하면 연산이 병렬로 수행되어야하는 boolean 플래그가 설정됨.

sequential로 병렬 스트림을 순차 스트림으로 바꿀 수도 있음

여러 번 호출하면? 마지막에 호출된 메서드가 전체 파이프라인에 영향을 줌

### ForkJoinPool로 병렬 스트림 사용하기

병렬 스트림은 내부적으로 ForkJoinPool을 사용함

프로세서 수, Runtime.getRuntime(), availableProcessors()가 반환하는 값에 상응하는 스레드를 가짐

ForkJoinPool은 자바에서 병렬 프로그래밍을 지원하기 위한 프레임워크 중 하나로, Java 7에서 소개되었음

이는 Fork-Join 태스크를 사용하여 병렬성을 활용할 수 있도록 설계된 스레드 풀임

간단히 설명하면, Fork-Join 프레임워크는 큰 작업을 더 작은 작업으로 분할하고, 각 작은 작업을 병렬로 실행한 다음 결과를 합치는 방식으로 동작한다


### LongStream.rangeClosed의 iterate보다 좋은 점
- 기본형 long을 사용하기 때문에 박싱 언박싱 오버헤드가 사라진다
- 쉽게 청크로 분할할 수 있는 숫자 범위를 생산한다

## 병렬 스트림 잘 쓰기
- 병렬 스트림과 병렬 계산을 할 때는 공유된 가변 상태를 피해야한다
- 순차 스트림보다 무조건 빠른 것은 아니다. 모르겠으면 벤치마크 돌려라
- 박싱 오버헤드를 막기 위해, 자바 8의 기본형 특화 스트림인 IntStream, LongStream, DoubleStream을 사용해라
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산: limit, findFirst. 데이터 순서에 의존하면 더 안 좋다
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려해라
- 스트림 자료구조를 적절하게 써라. ArrayList가 LinkedList보다 분할 하기 더 좋다. ArrayList는 요소를 탐색하지 않아도 리스트를 분할 할 수 있다

### 스트림 소스와 분해성
- 좋음: ArrayList, IntStream.range, HashSet, TreeSet








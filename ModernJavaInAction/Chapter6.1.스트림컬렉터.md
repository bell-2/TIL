# 스트림으로 데이터 수집

스트림의 연산은 filter, map	 같은 중간 연산과 count, findFirst, forEach, reduce 같은 최종 연산으로 구분된다.

1. 중간 연산
- 한 스트림을 다른 스트림으로 변환하는 연산
- 여러 연산을 연결할 수 있음
- 스트림 파이프 라인을 구성
- 스트림의 요소를 소비 하지 않음

2. 최종 연산
- 스트림 연산을 소비해서 최종 결과를 도출
- 스트림 파이프라인을 최적화하면서 계산 과정을 생략함


Collection, Collector, collect를 구분해보자~~

## Collector 컬렉터란?

함수형 프로그래밍에서는 무엇을 원하는지 직접 명시가 가능하다.
(스트림으로 얻든 for 반복문으로 하던 상관이 없잖슴)

각 요소를 리스트로 만들 때는 아래와 같이 두 방법이 가능.
- toList()
- groupingBy() 

### 고급 리듀싱 기능

다수준으로 그룹화를 하면, 명령형 프로그래밍과 함수형 프로그래밍 차이점이 더욱 커진다.

함수형 프로그래밍이 가독성과 유지보수성에 있어서 더 효율적이다. 또한 재사용성에 있어서도 좋다.

컬렉터의 최대 강점은 과정이 간단하고 유연하다.

collect에서는 리듀싱 연산으로 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다.


컬렉터 처리 순서

1. 스트림의 각 트랜잭션 탐색
2. 트랜잭션의 데이터를 추출
3. 트랜잭션 데이터를 그룹화 맵으로 추가 

Collector 인터페이스의 메서드를 어떻게 구현하느냐에 따라 스트림에 어떤 리듀싱 연산을 수행할지 결정된다.

Collectors에서는 컬렉터 인스턴스를 생성하는 정적 팩토리 메서드를 제공한다. (toList)

## 미리 정의된 컬렉터

Collectors 메서드에서 제공하는 기능

- 스트림 요소를 하나의 값으로 리듀스하고 요약
- 스트림 요소 그룹화: 다수준으로 그룹화하거나 결과 서브그룹에 리듀싱 연산도 적용할 수 있음
- 요소 분할: 한개의 인수를 받아 Predicate를 그룹화 함수로 사용함



1. DBMS 정의
- 데이터베이스 관리 시스템 Database Management System
- 사용자가 데이터에 관한 정보를 가능한 효율적이고 효과적으로 구성/복원/검색할 수 있도록 하는 응용 프로그램 모음
- 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리해주는 소프트웨어
- MySql, Oracle 등
  
*  DBMS 장점
   - 데이터가 구조적으로 저장되어 중복성이 제어
   - 입력한 데이터의 유효성을 검사, 무단 액세스에 대한 제한
   - 데이터 백업 및 복구 제공
   - 여러 사용자 인터페이스 제공
  
2.DB (Database)
- 여러 사람이 공유하여 사용할 목적으로 컴퓨터 시스템에 전자 방식으로 저장된 구조화된 정보
- 데이터의 체계적인 집합

3.SQL (Structured Query Language)
- 구조적 쿼리 언어
- 관계형 데이터베이스(RDBMS)에 정보를 저장하고 처리하기 위한 프로그래밍 언어
- 정보를 표 형식으로 저장, 행과 열은 다양한 데이터 속성과 데이터 값 간의 다양한 관계를 나타냄
- 자료의 검색 관리, 스키마 생성 수정 등을 위해 고안
- 데이터베이스 성능 유지 관리, 최적화에도 사용
- 3가지 범주
  - DDL (Data Definition Language): 데이터 정의어. CREATE/ALTER/DROP/TRUNCATE(초기화)
  - DML (Data Manipulation Language): 데이터 조작어. SELECT/INSERT/UPDATE/DELETE
  - DCL (Data Control Langurage) 데이터 제어어. 접속 권한. GRANT(승인)/REVOKE(취소)/COMMIT/ROLLBACK

4.ACID 규칙
- Atomicity(원자성): 한 트랜잭션의 모든 작업이 수행되든지 아니면 하나도 수행되지 않아야 함. 제대로 실행되지 않았다면 Roll back
- Consistency(일관성): 모든 트랜잭션은 데이터베이스에서 정한 무결성 고전을 만족해야함
- Isolation(격리성): 두 개의 트랜잭션이 서로에게 영향을 미칠 수 없음. 한 트랜잭션이 실행되는 동안의 값은 다른 트랜잭션이 접근할 수 없어야 함
- Durability(내구성): 트랜잭션이 성공적으로 끝난 뒤에는 비록 실패하더라도! 데이터베이스에 계속 유지되어야함

* Concurrency Control (병행제어)
- 트랜잭션을 안전하게 처리하고 ACID 규칙을 만족시키는 기술

5.RDBMS 
- 관계형 데이터 베이스 관리 시스템 (Relational DBMS)
- 데이터가 하나 이상의 열과 행의 테이블에 저장되어, 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 사전 정의된 관계
- 데이터를 구성하는 정보 모음
- Relation은 이러한 테이블 간의 상호작용을 기반으로 설정되는 여러 테이블 간의 논리적 연결
- 테이블 간, 외래 키를 이용한 Join이 가능
- Entity: 디비에서 표현하려고 하는 유형/무형의 객체로 서로 구별되는 것
  - 엔티티의 관계로 일대일/일대다/다대다 관계가 생성됨

6.NoSQL (Not Only SQL)
- 비관계형 데이터베이스 
- RDB와는 다른 형식으로 데이터를 저장
- API, 쿼리 언어, 쿼리별 언어를 사용하여 질의할 수 있음
- 실시간 웹 애플리케이션 및 빅데이터에서 많이 사용됨
- 요구사항이 빠르게 변화함에 따라 NoSQL 선호를 하기도..

7.NoSQL과 비관계형 데이터 베이스
마켓컬리?
1) 유연성
- 엄격한 스키마 없어도 됨. 자유로운 형식. 빠른 개발 가능
1) 확장성
- 서버를 확장하는 대신 상업용 하드웨어로 확장 가능. 트래픽 향상. 
1) 고성능
- 데이터 양, 트래픽 증가할 때 아주 좋음
- 아주 빠름.
1) 가용성
- 여러 서버, 데이터센터, 클라우드 리소스 전반의 데이터를 자동으로 복제
- 사용자 위치과 상관 없이 대기시간이 최소화. 관리 부담이 줄어듬
1) 고도의 기능성
- 큰 분산형 데이터 저장소를 위해 설계됨
- 온라인 쇼핑, 게이밍, 사물인터넷 등을 처리하기에 좋음

8.SQL vs NoSQL
- SQL: RDBMS는 구조화된 쿼리언어(SQL) 기반
-> 사용자는 고도로 구조화된 테이블에서 데이터에 접근/조작이 가능
- NoSQL: 데이터 접근 구문이 데이터베이스마다 다를 수 있음

9.RDBMS vs NoSQL
- RDBMS
    - 테이블이라고 불리는 데이터베이스에 객체가 저장되어있쥬
    - 스키마를 사전 정의 및 모든 행/열의 데이터 유형이 사전에 파악되어야 함
    - 여러 테이블이 키를 사용해 여러 테이블을 연결하는 방식으로 정보를 저장
    - 관계가 생성될 수밖에

- NoSQL Database
    - 사전에 스키마를 정의하지 않아도 저장이 가능함 -> 빠르게 데이터 작성, 반복
    - 그래프 기반, 문서지향.., 키-값 저장소 같은 특정 비즈니스 요구 사항에 적합함

10.NoSQL 데이터베이스 좀 더 보기
- 선택해야되는 경우
    - 유연한 스키마를 제공, 대량의 데이터, 낮은 응답 시간 요구하는 애플리케이션 구축에 어울림. 게이밍, 전자 상거래 등
- 선택 노노해야되는 경우
    - 비정규화된 데이터에 의존하고, 상대적으로 적은 수의 데이터/컨테이너에서 많이 쓰는데, 금융, 회계, 백오피스 같은 것들은 데이터 변형이나 데이터 중복을 방지하기 위해 정규화된 데이터에 의존함
    - 쿼리가 복잡해지면 RDBMS를 쓰는게 더 좋음

11.데이터베이스 유형 관계
3가지 유형 단계가 있다
* Entity: 디비에서 표현하려고 하는 유형/무형의 객체로 서로 구별되는 것
- 일대일: 상대 엔티티와 단 하나의 관계를 가지는 것
- 일대다: 기본 및 외래 키 관계가 있는 다른 테이블과 관계가 있음. 
  - PK(Primary Key): 각 엔티티를 식별할 수 있는 대표키. Unique한 키
  - FK(Foreign Key): 다른 테이블의 기본키를 참조
- 다대다: 양쪽 엔티티 모두에서 일대다 관계를 가지는 것. 서로의 PK를 자신의 외래키 컬럼으로 갖고 있으면 됨

12.정규화/비정규화
- 정규화: 데이터 무결성을 유지하기 위해, 잘 정의된 방식으로 테이블을 분할하여 중복 데이터를 제거하는 프로세스
  - RDBMS에서 중복을 최소화하기 위해 데이터를 구조화하는 작업. 저장공간 절약
- 비정규화: 복잡한 쿼리속도를 높이고, 성능을 향상 시키기 위해 중복 데이터를 추가하는 프로세스
  - join이 줄어들 수 있음

13.데이터베이스 뷰
- 허용된 데이터를 제한적으로 보여주기 위한 가상 테이블. 물리적으로는 존재하지 않지만 사용자에게 있는것처럼 보임

14.ER 모델 (Entity-Relation)
- 데이터 베이스의 개념적 뷰를 정의하는 엔티티-관계 모델
- 실제 실체와 그 연관 관계를 보여줌

15.Entity/Entity Type/Entity Set
- 엔터티: 디비에서 표현하려고 하는 유형/무형의 객체로 서로 구별되는 것
- 엔터티 타입: 유사한 특성을 가지는 엔터티 집합
- 엔터티 집합: 데이터베이스에 설정된 엔터티는 특정 엔터티 유형을 갖는 집합을 나타냄

16.데이터베이스 트랜잭션
- 데이터베이스의 일관성 있는 상태를 다른 것으로 변경하는 작업 순서
* ACID
    - Atomicity(원자성): 트랜잭션으로 다 반영이 되던지, 다 안되던지
    - Consistency(일관성): 트랜잭션이 완료된 후에는, 상태가 일관 되어야 함
    - Isolation(독립성): 하나의 트랜잭션이 다른 트랜잭션에 영향이 있으면 안됨
    - Duration(지속성): 완료되면, 시스템에 문제가 있어도 변하면 안된다

17.인덱스
- 테이블에 대한 동작의 속도를 높여주는 자료구조. 빠른 검색을 할 수 있고, 효율적이다
- 테이블 내의 1개의 컬럼/여러개의 컬럼으로 생성할 수 있다
- 데이터 양이 많고, 검색이 변경보다 빈번할 경우 사용할 수 있다
- DB에 10% 정도 공간이 요구되고, 인덱스 생성 시간이 요구되므로 성능 문제가 있을 수도 있다

18.인덱스 헌팅
- 인덱스 수집을 향상 시켜, 데이터베이스 성능과 쿼리 성능을 향상시키는 프로세스
- 쿼리 최적화 프로그램을 사용해서 쿼리를 조정할 수 있다.
- 인덱스 및 쿼리 배포의 성능 및 효과를 관찰할 수 있다

19.검사점(CheckPoint)
- 모든 로그가 저장 디스크에 영구적으로 저장되고, 일관성이 없는 지점을 선언함
- 충돌이 발생하면 시스템이 검사점에서 다시 시작할 수 있어서, 작업량과 시간이 절약됨

20.데이터 사전(Data Dictionary)
- 데이터 사전은 테이블과 데이터베이스 개체의 내용과 구조를 설명하는 정보 집합.
- 읽기전용으로 제공되는 테이블 및 뷰들의 집합으로, 데이터베이스 전반에 대한 정보를 제공
- Oracle은 데이터베이스 명령이 실행될 때마다 데이터 사전을 Access 한다
  - 정보 내용: 사용자 정보, 권한/룰 정보, 스키마 객체, 무결성 제약조건, 구조 정보 등등

21.기본키와 복합키 (Primary Key vs Compound Key)
- 키: 컬럼에 들어가는 데이터들을 어떻게 정의할지에 대해 정한 규칙
- 기본키: 모든 행 데이터가 고유하게 식별되는 테이블의 열. 기본키는 null이면 안됨. 중복 되어서도 안됨. 유일한 값이어야 함
  - Unique Key: 얘도 테이블에서 유일해야하고, 중복을 허용하지 않지만, NULL 값이 허용됨. 유일만 하다 (핸드폰 번호처럼)
- 복합키: 열 세트가 테이블의 모든 행을 고유하게 식별하는 후보키. 기본키가 되지 못한 컬럼들을 묶어서 기본키처럼 사용
  * 후보키
    - 기본키가 될 수 있는 컬럼들. 만약 기본키가 중복이 되어야하는 경우가 생긴다면? 기본키를 다시 정해야하는데, 그때 대체제

22.트리거 (Trigger, 방아쇠: 방아쇠를 당기면 총기 내부에서 일련의 작업을 통해 총알이 날아가쥬)
- 테이블에서 INSERT, DELETE, UPDATE 같은 DML 이벤트가 발생했을 때, 자동으로 실행되는 명령 세트
  - 사용자가 호출하는 것이 아니라, 자동으로!! 호출되는 것을 의미.
  - 예시) 판매 집계 테이블: 실시간으로 데이터가 입력될 때마다 판매 테이블이 업데이트 된다던가.

23.저장 프로 시저 (Stored Procedure)
- 사전 컴파일된 SQL 쿼리의 모음. 
- 하나의 요청으로 여러 SQL 문을 실행할 수 있다. (반복되는 쿼리를 저장 프로시저로 만들 수 있다)

24.DELETE vs TRUNCATE vs DROP
- DELETE:  연산을 실행한 후, 손실된 데이터를 검색하기 위해, 커밋/롤백을 수행할 수 있음 OOOO
  - WHERE 절을 사용해서, 데이터를 선택하여 삭제하는 것. 조건절을 사용 안하고 테이블 삭제 해도, 내부적으로는 한줄 한줄 제거함
  - 원하는 데이터글 골라서 삭제할 때 사용
- TRUNCATE(자르다): 조작을 실행한 후, 손실된 데이터를  검색하기 위해, 커밋/롤백 수행 못함
  - 전체 데이터를 삭제할 때 사용
  - TRUNCATE TABLE dbtable; 하게 되면 CREATE TABLE을 한 직후와 같다
- DROP: 기본 키/왜래키와 같은 테이블, 키를 삭제하는데 사용
  - 테이블 자체를 완전히 날려버리는 것. 자동 커밋 되기 때문에, 이미 지운 데이터는 돌릴 수 없다

25.이상현상
- 삭제 이상: 원하지 않는 자료가 삽입되거나, 자료가 부족해 삽입이 안되는 것
- 삭제 이상: 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제 되어 정보 손실 발생
- 갱신 이상: 정확하지 않거나 일부의 튜플만 갱신되어, 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점

26.트리거
- 자동으로 실행되도록 정의된 저장 프로시저
- INSERT/UPDATE/DELETE 문에 대한 응답으로 자동 호출

27.데이터베이스 무결성
- 데이터 베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 정확성
- 개체 무결성: 기본키를 구성하는 속성은 NULL 값이거나 중복 값을 가질 수 없다
- 참조 무결성: 외래키 값은 NULL이거나 참조 테이블의 기본키 값이어야 한다

28.조인
- 두개 이상의 테이블이나 데이터 베이스를 연결하여 데이터를 검색하는 방법
- Inner Join
- Left Join
- Right Join
- Outer Join

29.교착상태
- 2개 이상의 트랜잭션이 특정 테이블/행에 락을 걸고, 다른 트랜잭션이 소유하고 있는 락을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태
- 방지 방법
  - 트랜잭션을 자주 커밋
  - 정해진 순서로 테이블에 접근

30.NoSQL의 특징
- NoSQL은 스키마가 겂다. 데이터 관계와 정해진 규격이 없다 (테이블-컬럼 정의)
- 관계 정의가 없으니 Join이 불가능. 
- 트랜잭션을 지원하지 않음
- 분산 처리 기능을 쉽게 제공함
- 어떤 상황에서?
  - 비정형 데이터를 저장해야할 때




---

출처
- https://hyonee.tistory.com/41 (질문참고)